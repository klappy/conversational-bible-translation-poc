
import {createRequire as ___nfyCreateRequire} from "module";
import {fileURLToPath as ___nfyFileURLToPath} from "url";
import {dirname as ___nfyPathDirname} from "path";
let __filename=___nfyFileURLToPath(import.meta.url);
let __dirname=___nfyPathDirname(___nfyFileURLToPath(import.meta.url));
let require=___nfyCreateRequire(import.meta.url);


// netlify/functions/canvas-state.js
import { promises as fs } from "fs";
import { join } from "path";
var STATE_FILE = join("/tmp", "canvas-state.json");
var DEFAULT_STATE = {
  styleGuide: {
    conversationLanguage: "English",
    // Language of Wider Communication
    sourceLanguage: "English",
    // Translating from
    targetLanguage: "English",
    // Translating into
    languagePair: "English \u2192 English",
    // Legacy, kept for compatibility
    readingLevel: "Grade 1",
    tone: "Narrator, engaging tone",
    philosophy: "Meaning-based"
  },
  glossary: {
    terms: {}
  },
  scriptureCanvas: {
    verses: {}
  },
  feedback: {
    comments: []
  },
  workflow: {
    currentPhase: "planning",
    currentVerse: "Ruth 1:1",
    currentPhrase: 0,
    phrasesCompleted: {},
    totalPhrases: 0
  },
  metadata: {
    lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
    version: 1
  }
};
async function loadState() {
  try {
    const data = await fs.readFile(STATE_FILE, "utf8");
    return JSON.parse(data);
  } catch (error) {
    return { ...DEFAULT_STATE };
  }
}
async function saveState(state) {
  try {
    await fs.writeFile(STATE_FILE, JSON.stringify(state, null, 2));
    return true;
  } catch (error) {
    console.error("Error saving state:", error);
    return false;
  }
}
async function getState() {
  const globalState = await loadState();
  return {
    ...globalState,
    metadata: {
      ...globalState.metadata,
      retrieved: (/* @__PURE__ */ new Date()).toISOString()
    }
  };
}
async function updateState(updates, agentId = "user") {
  try {
    if (!updates || typeof updates !== "object") {
      throw new Error("Invalid updates provided");
    }
    let globalState = await loadState();
    globalState = deepMerge(globalState, updates);
    globalState.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    globalState.metadata.version = (globalState.metadata.version || 1) + 1;
    await saveState(globalState);
    return {
      success: true,
      state: await getState()
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
async function resetState() {
  const globalState = {
    styleGuide: {
      conversationLanguage: "English",
      // Language of Wider Communication
      sourceLanguage: "English",
      // Translating from
      targetLanguage: "English",
      // Translating into
      languagePair: "English \u2192 English",
      // Legacy, kept for compatibility
      readingLevel: "Grade 1",
      tone: "Narrator, engaging tone",
      philosophy: "Meaning-based"
    },
    glossary: {
      terms: {}
    },
    scriptureCanvas: {
      verses: {}
    },
    feedback: {
      comments: []
    },
    workflow: {
      currentPhase: "planning",
      currentVerse: "Ruth 1:1",
      currentPhrase: 0,
      phrasesCompleted: {},
      totalPhrases: 0
    },
    metadata: {
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
      version: 1
    }
  };
  await saveState(globalState);
  return getState();
}
function deepMerge(target, source) {
  const output = { ...target };
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isObject(source[key])) {
        if (!(key in target)) {
          output[key] = source[key];
        } else {
          output[key] = deepMerge(target[key], source[key]);
        }
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
var handler = async (req, context) => {
  const headers = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Content-Type",
    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
    "Content-Type": "application/json"
  };
  if (req.method === "OPTIONS") {
    return new Response("OK", { headers });
  }
  try {
    const url = new URL(req.url);
    const path = url.pathname.replace("/.netlify/functions/canvas-state", "");
    if (req.method === "GET" && (path === "" || path === "/")) {
      const state = await getState();
      return new Response(JSON.stringify(state), {
        status: 200,
        headers
      });
    }
    if (req.method === "GET" && path === "/history") {
      const state = await getState();
      return new Response(JSON.stringify({
        history: [],
        // No longer storing history with file-based approach
        currentState: state
      }), {
        status: 200,
        headers
      });
    }
    if (req.method === "POST" && path === "/update") {
      const body = await req.json();
      const { updates, agentId } = body;
      const result = await updateState(updates, agentId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 400,
        headers
      });
    }
    if (req.method === "POST" && path === "/reset") {
      const state = await resetState();
      return new Response(JSON.stringify({
        success: true,
        state
      }), {
        status: 200,
        headers
      });
    }
    return new Response(JSON.stringify({
      error: `Method ${req.method} not allowed for path ${path}`
    }), {
      status: 405,
      headers
    });
  } catch (error) {
    console.error("Canvas state error:", error);
    return new Response(JSON.stringify({
      error: "Failed to process canvas state request",
      details: error.message
    }), {
      status: 500,
      headers: {
        ...headers,
        "Content-Type": "application/json"
      }
    });
  }
};
var canvas_state_default = handler;
export {
  canvas_state_default as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibmV0bGlmeS9mdW5jdGlvbnMvY2FudmFzLXN0YXRlLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIENhbnZhcyBTdGF0ZSBNYW5hZ2VtZW50XG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBvZiBhbGwgY2FudmFzIGFydGlmYWN0cyBzZXJ2ZXItc2lkZVxuICogVGhpcyBpcyB0aGUgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIGFwcGxpY2F0aW9uIHN0YXRlXG4gKi9cblxuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbi8vIFN0YXRlIGZpbGUgcGF0aCAoaW4gdGVtcCBkaXJlY3RvcnkgZm9yIGxvY2FsIGRldilcbmNvbnN0IFNUQVRFX0ZJTEUgPSBqb2luKCcvdG1wJywgJ2NhbnZhcy1zdGF0ZS5qc29uJyk7XG5cbi8vIERlZmF1bHQgc3RhdGVcbmNvbnN0IERFRkFVTFRfU1RBVEUgPSB7XG4gIHN0eWxlR3VpZGU6IHtcbiAgICBjb252ZXJzYXRpb25MYW5ndWFnZTogXCJFbmdsaXNoXCIsICAvLyBMYW5ndWFnZSBvZiBXaWRlciBDb21tdW5pY2F0aW9uXG4gICAgc291cmNlTGFuZ3VhZ2U6IFwiRW5nbGlzaFwiLCAgICAgICAgLy8gVHJhbnNsYXRpbmcgZnJvbVxuICAgIHRhcmdldExhbmd1YWdlOiBcIkVuZ2xpc2hcIiwgICAgICAgIC8vIFRyYW5zbGF0aW5nIGludG9cbiAgICBsYW5ndWFnZVBhaXI6IFwiRW5nbGlzaCBcdTIxOTIgRW5nbGlzaFwiLCAvLyBMZWdhY3ksIGtlcHQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZWFkaW5nTGV2ZWw6IFwiR3JhZGUgMVwiLFxuICAgIHRvbmU6IFwiTmFycmF0b3IsIGVuZ2FnaW5nIHRvbmVcIixcbiAgICBwaGlsb3NvcGh5OiBcIk1lYW5pbmctYmFzZWRcIlxuICB9LFxuICBnbG9zc2FyeToge1xuICAgIHRlcm1zOiB7fVxuICB9LFxuICBzY3JpcHR1cmVDYW52YXM6IHtcbiAgICB2ZXJzZXM6IHt9XG4gIH0sXG4gIGZlZWRiYWNrOiB7XG4gICAgY29tbWVudHM6IFtdXG4gIH0sXG4gIHdvcmtmbG93OiB7XG4gICAgY3VycmVudFBoYXNlOiBcInBsYW5uaW5nXCIsXG4gICAgY3VycmVudFZlcnNlOiBcIlJ1dGggMToxXCIsXG4gICAgY3VycmVudFBocmFzZTogMCxcbiAgICBwaHJhc2VzQ29tcGxldGVkOiB7fSxcbiAgICB0b3RhbFBocmFzZXM6IDBcbiAgfSxcbiAgbWV0YWRhdGE6IHtcbiAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHZlcnNpb246IDFcbiAgfVxufTtcblxuLyoqXG4gKiBMb2FkIHN0YXRlIGZyb20gZmlsZSBvciByZXR1cm4gZGVmYXVsdFxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkU3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZzLnJlYWRGaWxlKFNUQVRFX0ZJTEUsICd1dGY4Jyk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRmlsZSBkb2Vzbid0IGV4aXN0IG9yIGlzIGludmFsaWQsIHJldHVybiBkZWZhdWx0XG4gICAgcmV0dXJuIHsgLi4uREVGQVVMVF9TVEFURSB9O1xuICB9XG59XG5cbi8qKlxuICogU2F2ZSBzdGF0ZSB0byBmaWxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNhdmVTdGF0ZShzdGF0ZSkge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShTVEFURV9GSUxFLCBKU09OLnN0cmluZ2lmeShzdGF0ZSwgbnVsbCwgMikpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzdGF0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHN0YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICBjb25zdCBnbG9iYWxTdGF0ZSA9IGF3YWl0IGxvYWRTdGF0ZSgpO1xuICByZXR1cm4ge1xuICAgIC4uLmdsb2JhbFN0YXRlLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICAuLi5nbG9iYWxTdGF0ZS5tZXRhZGF0YSxcbiAgICAgIHJldHJpZXZlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc3RhdGUgd2l0aCB2YWxpZGF0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHVwZGF0ZXMsIGFnZW50SWQgPSAndXNlcicpIHtcbiAgdHJ5IHtcbiAgICAvLyBWYWxpZGF0ZSB1cGRhdGVzXG4gICAgaWYgKCF1cGRhdGVzIHx8IHR5cGVvZiB1cGRhdGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVwZGF0ZXMgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIGN1cnJlbnQgc3RhdGVcbiAgICBsZXQgZ2xvYmFsU3RhdGUgPSBhd2FpdCBsb2FkU3RhdGUoKTtcblxuICAgIC8vIEFwcGx5IHVwZGF0ZXMgKGRlZXAgbWVyZ2UpXG4gICAgZ2xvYmFsU3RhdGUgPSBkZWVwTWVyZ2UoZ2xvYmFsU3RhdGUsIHVwZGF0ZXMpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBtZXRhZGF0YVxuICAgIGdsb2JhbFN0YXRlLm1ldGFkYXRhLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIGdsb2JhbFN0YXRlLm1ldGFkYXRhLnZlcnNpb24gPSAoZ2xvYmFsU3RhdGUubWV0YWRhdGEudmVyc2lvbiB8fCAxKSArIDE7XG5cbiAgICAvLyBTYXZlIHRvIGZpbGVcbiAgICBhd2FpdCBzYXZlU3RhdGUoZ2xvYmFsU3RhdGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBzdGF0ZTogYXdhaXQgZ2V0U3RhdGUoKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVzZXQgc3RhdGUgdG8gaW5pdGlhbCB2YWx1ZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgY29uc3QgZ2xvYmFsU3RhdGUgPSB7XG4gICAgc3R5bGVHdWlkZToge1xuICAgICAgY29udmVyc2F0aW9uTGFuZ3VhZ2U6IFwiRW5nbGlzaFwiLCAgLy8gTGFuZ3VhZ2Ugb2YgV2lkZXIgQ29tbXVuaWNhdGlvblxuICAgICAgc291cmNlTGFuZ3VhZ2U6IFwiRW5nbGlzaFwiLCAgICAgICAgLy8gVHJhbnNsYXRpbmcgZnJvbVxuICAgICAgdGFyZ2V0TGFuZ3VhZ2U6IFwiRW5nbGlzaFwiLCAgICAgICAgLy8gVHJhbnNsYXRpbmcgaW50b1xuICAgICAgbGFuZ3VhZ2VQYWlyOiBcIkVuZ2xpc2ggXHUyMTkyIEVuZ2xpc2hcIiwgLy8gTGVnYWN5LCBrZXB0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgICByZWFkaW5nTGV2ZWw6IFwiR3JhZGUgMVwiLFxuICAgICAgdG9uZTogXCJOYXJyYXRvciwgZW5nYWdpbmcgdG9uZVwiLFxuICAgICAgcGhpbG9zb3BoeTogXCJNZWFuaW5nLWJhc2VkXCJcbiAgICB9LFxuICAgIGdsb3NzYXJ5OiB7XG4gICAgICB0ZXJtczoge31cbiAgICB9LFxuICAgIHNjcmlwdHVyZUNhbnZhczoge1xuICAgICAgdmVyc2VzOiB7fVxuICAgIH0sXG4gICAgZmVlZGJhY2s6IHtcbiAgICAgIGNvbW1lbnRzOiBbXVxuICAgIH0sXG4gICAgd29ya2Zsb3c6IHtcbiAgICAgIGN1cnJlbnRQaGFzZTogXCJwbGFubmluZ1wiLFxuICAgICAgY3VycmVudFZlcnNlOiBcIlJ1dGggMToxXCIsXG4gICAgICBjdXJyZW50UGhyYXNlOiAwLFxuICAgICAgcGhyYXNlc0NvbXBsZXRlZDoge30sXG4gICAgICB0b3RhbFBocmFzZXM6IDBcbiAgICB9LFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH1cbiAgfTtcbiAgYXdhaXQgc2F2ZVN0YXRlKGdsb2JhbFN0YXRlKTtcbiAgcmV0dXJuIGdldFN0YXRlKCk7XG59XG5cbi8qKlxuICogRGVlcCBtZXJnZSB1dGlsaXR5IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlZXBNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICBcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSk7XG59XG5cbi8qKlxuICogTmV0bGlmeSBGdW5jdGlvbiBIYW5kbGVyXG4gKi9cbmNvbnN0IGhhbmRsZXIgPSBhc3luYyAocmVxLCBjb250ZXh0KSA9PiB7XG4gIC8vIEVuYWJsZSBDT1JTXG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIjogXCIqXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCI6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCI6IFwiR0VULCBQT1NULCBQVVQsIERFTEVURSwgT1BUSU9OU1wiLFxuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gIH07XG5cbiAgLy8gSGFuZGxlIHByZWZsaWdodFxuICBpZiAocmVxLm1ldGhvZCA9PT0gXCJPUFRJT05TXCIpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiT0tcIiwgeyBoZWFkZXJzIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aG5hbWUucmVwbGFjZSgnLy5uZXRsaWZ5L2Z1bmN0aW9ucy9jYW52YXMtc3RhdGUnLCAnJyk7XG5cbiAgLy8gR0VUIC9zdGF0ZSAtIEdldCBjdXJyZW50IHN0YXRlXG4gIGlmIChyZXEubWV0aG9kID09PSBcIkdFVFwiICYmIChwYXRoID09PSBcIlwiIHx8IHBhdGggPT09IFwiL1wiKSkge1xuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlKSwgeyBcbiAgICAgIHN0YXR1czogMjAwLCBcbiAgICAgIGhlYWRlcnMgXG4gICAgfSk7XG4gIH1cblxuICAvLyBHRVQgL2hpc3RvcnkgLSBHZXQgc3RhdGUgaGlzdG9yeSAoZGVwcmVjYXRlZCBmb3IgZmlsZS1iYXNlZCBzdG9yYWdlKVxuICBpZiAocmVxLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBwYXRoID09PSBcIi9oaXN0b3J5XCIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IGdldFN0YXRlKCk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgaGlzdG9yeTogW10sICAvLyBObyBsb25nZXIgc3RvcmluZyBoaXN0b3J5IHdpdGggZmlsZS1iYXNlZCBhcHByb2FjaFxuICAgICAgY3VycmVudFN0YXRlOiBzdGF0ZVxuICAgIH0pLCB7IFxuICAgICAgc3RhdHVzOiAyMDAsIFxuICAgICAgaGVhZGVycyBcbiAgICB9KTtcbiAgfVxuXG4gICAgLy8gUE9TVCAvdXBkYXRlIC0gVXBkYXRlIHN0YXRlXG4gICAgaWYgKHJlcS5tZXRob2QgPT09IFwiUE9TVFwiICYmIHBhdGggPT09IFwiL3VwZGF0ZVwiKSB7XG4gICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICAgIGNvbnN0IHsgdXBkYXRlcywgYWdlbnRJZCB9ID0gYm9keTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBkYXRlU3RhdGUodXBkYXRlcywgYWdlbnRJZCk7XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdWNjZXNzID8gMjAwIDogNDAwLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQT1NUIC9yZXNldCAtIFJlc2V0IHN0YXRlXG4gICAgaWYgKHJlcS5tZXRob2QgPT09IFwiUE9TVFwiICYmIHBhdGggPT09IFwiL3Jlc2V0XCIpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgcmVzZXRTdGF0ZSgpO1xuICAgICAgXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH0pLCB7XG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2Qgbm90IGFsbG93ZWRcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICBlcnJvcjogYE1ldGhvZCAke3JlcS5tZXRob2R9IG5vdCBhbGxvd2VkIGZvciBwYXRoICR7cGF0aH1gIFxuICAgIH0pLCB7IFxuICAgICAgc3RhdHVzOiA0MDUsIFxuICAgICAgaGVhZGVycyBcbiAgICB9KTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgc3RhdGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICBlcnJvcjogXCJGYWlsZWQgdG8gcHJvY2VzcyBjYW52YXMgc3RhdGUgcmVxdWVzdFwiLFxuICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZVxuICAgIH0pLCB7XG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7QUFNQSxTQUFTLFlBQVksVUFBVTtBQUMvQixTQUFTLFlBQVk7QUFHckIsSUFBTSxhQUFhLEtBQUssUUFBUSxtQkFBbUI7QUFHbkQsSUFBTSxnQkFBZ0I7QUFBQSxFQUNwQixZQUFZO0FBQUEsSUFDVixzQkFBc0I7QUFBQTtBQUFBLElBQ3RCLGdCQUFnQjtBQUFBO0FBQUEsSUFDaEIsZ0JBQWdCO0FBQUE7QUFBQSxJQUNoQixjQUFjO0FBQUE7QUFBQSxJQUNkLGNBQWM7QUFBQSxJ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
