
import {createRequire as ___nfyCreateRequire} from "module";
import {fileURLToPath as ___nfyFileURLToPath} from "url";
import {dirname as ___nfyPathDirname} from "path";
let __filename=___nfyFileURLToPath(import.meta.url);
let __dirname=___nfyPathDirname(___nfyFileURLToPath(import.meta.url));
let require=___nfyCreateRequire(import.meta.url);


// netlify/functions/canvas-state.js
import { getStore } from "@netlify/blobs";
var DEFAULT_STATE = {
  styleGuide: {
    conversationLanguage: "English",
    // Language of Wider Communication
    sourceLanguage: "English",
    // Translating from
    targetLanguage: "English",
    // Translating into
    languagePair: "English \u2192 English",
    // Legacy, kept for compatibility
    readingLevel: "Grade 1",
    tone: "Narrator, engaging tone",
    philosophy: "Meaning-based"
  },
  glossary: {
    terms: {}
  },
  scriptureCanvas: {
    verses: {}
  },
  feedback: {
    comments: []
  },
  workflow: {
    currentPhase: "planning",
    currentVerse: "Ruth 1:1",
    currentPhrase: 0,
    phrasesCompleted: {},
    totalPhrases: 0
  },
  metadata: {
    lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
    version: 1
  }
};
function getBlobStore(context) {
  const storeConfig = {
    name: "canvas-state"
  };
  if (context.site?.id || process.env.SITE_ID) {
    storeConfig.siteID = context.site?.id || process.env.SITE_ID;
  }
  if (context.token || process.env.NETLIFY_AUTH_TOKEN) {
    storeConfig.token = context.token || process.env.NETLIFY_AUTH_TOKEN;
  }
  return getStore(storeConfig);
}
function getStateKey(req) {
  const url = new URL(req.url);
  const sessionId = req.headers.get?.("x-session-id") || req.headers["x-session-id"] || url.searchParams.get("session");
  return sessionId ? `session_${sessionId}` : "default";
}
async function loadState(store, stateKey) {
  try {
    const data = await store.get(stateKey);
    if (data) {
      return JSON.parse(data);
    }
    return { ...DEFAULT_STATE };
  } catch (error) {
    console.error("Error loading state from Blobs:", error);
    return { ...DEFAULT_STATE };
  }
}
async function saveState(store, stateKey, state) {
  try {
    await store.set(stateKey, JSON.stringify(state));
    return true;
  } catch (error) {
    console.error("Error saving state to Blobs:", error);
    return false;
  }
}
async function getState(store, stateKey) {
  const globalState = await loadState(store, stateKey);
  return {
    ...globalState,
    metadata: {
      ...globalState.metadata,
      retrieved: (/* @__PURE__ */ new Date()).toISOString(),
      sessionId: stateKey
    }
  };
}
async function updateState(store, stateKey, updates, agentId = "user") {
  try {
    if (!updates || typeof updates !== "object") {
      throw new Error("Invalid updates provided");
    }
    let globalState = await loadState(store, stateKey);
    globalState = deepMerge(globalState, updates);
    globalState.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    globalState.metadata.version = (globalState.metadata.version || 1) + 1;
    await saveState(store, stateKey, globalState);
    return {
      success: true,
      state: await getState(store, stateKey)
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
async function resetState(store, stateKey) {
  const globalState = {
    ...DEFAULT_STATE,
    metadata: {
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
      version: 1,
      sessionId: stateKey
    }
  };
  await saveState(store, stateKey, globalState);
  return getState(store, stateKey);
}
async function listSessions(store) {
  try {
    const { blobs } = await store.list();
    return blobs.map((blob) => ({
      key: blob.key,
      // Extract session ID from key
      sessionId: blob.key.startsWith("session_") ? blob.key.replace("session_", "") : blob.key,
      isDefault: blob.key === "default"
    }));
  } catch (error) {
    console.error("Error listing sessions:", error);
    return [];
  }
}
function deepMerge(target, source) {
  const output = { ...target };
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isObject(source[key])) {
        if (!(key in target)) {
          output[key] = source[key];
        } else {
          output[key] = deepMerge(target[key], source[key]);
        }
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
var handler = async (req, context) => {
  const headers = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Content-Type, X-Session-ID",
    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
    "Content-Type": "application/json"
  };
  if (req.method === "OPTIONS") {
    return new Response("OK", { headers });
  }
  try {
    const store = getBlobStore(context);
    const stateKey = getStateKey(req);
    const url = new URL(req.url);
    const path = url.pathname.replace("/.netlify/functions/canvas-state", "");
    console.log(`Canvas state request: ${req.method} ${path}, session: ${stateKey}`);
    if (req.method === "GET" && (path === "" || path === "/")) {
      const state = await getState(store, stateKey);
      return new Response(JSON.stringify(state), {
        status: 200,
        headers
      });
    }
    if (req.method === "GET" && path === "/sessions") {
      const sessions = await listSessions(store);
      return new Response(
        JSON.stringify({
          sessions,
          currentSession: stateKey
        }),
        {
          status: 200,
          headers
        }
      );
    }
    if (req.method === "GET" && path === "/history") {
      const state = await getState(store, stateKey);
      return new Response(
        JSON.stringify({
          history: [],
          // No longer storing history with Blobs approach
          currentState: state
        }),
        {
          status: 200,
          headers
        }
      );
    }
    if (req.method === "POST" && path === "/update") {
      const body = await req.json();
      const { updates, agentId } = body;
      const result = await updateState(store, stateKey, updates, agentId);
      return new Response(JSON.stringify(result), {
        status: result.success ? 200 : 400,
        headers
      });
    }
    if (req.method === "POST" && path === "/reset") {
      const state = await resetState(store, stateKey);
      return new Response(
        JSON.stringify({
          success: true,
          state
        }),
        {
          status: 200,
          headers
        }
      );
    }
    if (req.method === "DELETE" && path === "/session") {
      try {
        await store.delete(stateKey);
        return new Response(
          JSON.stringify({
            success: true,
            message: `Session ${stateKey} deleted`
          }),
          {
            status: 200,
            headers
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({
            success: false,
            error: error.message
          }),
          {
            status: 500,
            headers
          }
        );
      }
    }
    return new Response(
      JSON.stringify({
        error: `Method ${req.method} not allowed for path ${path}`
      }),
      {
        status: 405,
        headers
      }
    );
  } catch (error) {
    console.error("Canvas state error:", error);
    return new Response(
      JSON.stringify({
        error: "Failed to process canvas state request",
        details: error.message
      }),
      {
        status: 500,
        headers: {
          ...headers,
          "Content-Type": "application/json"
        }
      }
    );
  }
};
var canvas_state_default = handler;
export {
  canvas_state_default as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibmV0bGlmeS9mdW5jdGlvbnMvY2FudmFzLXN0YXRlLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIENhbnZhcyBTdGF0ZSBNYW5hZ2VtZW50IHdpdGggTmV0bGlmeSBCbG9ic1xuICogTWFuYWdlcyB0aGUgc3RhdGUgb2YgYWxsIGNhbnZhcyBhcnRpZmFjdHMgdXNpbmcgTmV0bGlmeSBCbG9icyBmb3IgcGVyc2lzdGVuY2VcbiAqIFRoaXMgaXMgdGhlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBhcHBsaWNhdGlvbiBzdGF0ZVxuICovXG5cbmltcG9ydCB7IGdldFN0b3JlIH0gZnJvbSBcIkBuZXRsaWZ5L2Jsb2JzXCI7XG5cbi8vIERlZmF1bHQgc3RhdGVcbmNvbnN0IERFRkFVTFRfU1RBVEUgPSB7XG4gIHN0eWxlR3VpZGU6IHtcbiAgICBjb252ZXJzYXRpb25MYW5ndWFnZTogXCJFbmdsaXNoXCIsIC8vIExhbmd1YWdlIG9mIFdpZGVyIENvbW11bmljYXRpb25cbiAgICBzb3VyY2VMYW5ndWFnZTogXCJFbmdsaXNoXCIsIC8vIFRyYW5zbGF0aW5nIGZyb21cbiAgICB0YXJnZXRMYW5ndWFnZTogXCJFbmdsaXNoXCIsIC8vIFRyYW5zbGF0aW5nIGludG9cbiAgICBsYW5ndWFnZVBhaXI6IFwiRW5nbGlzaCBcdTIxOTIgRW5nbGlzaFwiLCAvLyBMZWdhY3ksIGtlcHQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICByZWFkaW5nTGV2ZWw6IFwiR3JhZGUgMVwiLFxuICAgIHRvbmU6IFwiTmFycmF0b3IsIGVuZ2FnaW5nIHRvbmVcIixcbiAgICBwaGlsb3NvcGh5OiBcIk1lYW5pbmctYmFzZWRcIixcbiAgfSxcbiAgZ2xvc3Nhcnk6IHtcbiAgICB0ZXJtczoge30sXG4gIH0sXG4gIHNjcmlwdHVyZUNhbnZhczoge1xuICAgIHZlcnNlczoge30sXG4gIH0sXG4gIGZlZWRiYWNrOiB7XG4gICAgY29tbWVudHM6IFtdLFxuICB9LFxuICB3b3JrZmxvdzoge1xuICAgIGN1cnJlbnRQaGFzZTogXCJwbGFubmluZ1wiLFxuICAgIGN1cnJlbnRWZXJzZTogXCJSdXRoIDE6MVwiLFxuICAgIGN1cnJlbnRQaHJhc2U6IDAsXG4gICAgcGhyYXNlc0NvbXBsZXRlZDoge30sXG4gICAgdG90YWxQaHJhc2VzOiAwLFxuICB9LFxuICBtZXRhZGF0YToge1xuICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdmVyc2lvbjogMSxcbiAgfSxcbn07XG5cbi8qKlxuICogR2V0IHRoZSBOZXRsaWZ5IEJsb2JzIHN0b3JlIGZvciB0aGUgY3VycmVudCBzaXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2JTdG9yZShjb250ZXh0KSB7XG4gIC8vIEluIHByb2R1Y3Rpb24sIGdldFN0b3JlIHNob3VsZCB3b3JrIHdpdGhvdXQgZXhwbGljaXQgc2l0ZUlEL3Rva2VuXG4gIC8vIGFzIE5ldGxpZnkgcHJvdmlkZXMgdGhlc2UgYXV0b21hdGljYWxseSBpbiB0aGUgcnVudGltZSBlbnZpcm9ubWVudFxuICBjb25zdCBzdG9yZUNvbmZpZyA9IHtcbiAgICBuYW1lOiBcImNhbnZhcy1zdGF0ZVwiLFxuICB9O1xuXG4gIC8vIE9ubHkgYWRkIHNpdGVJRCBhbmQgdG9rZW4gaWYgdGhleSBleGlzdCAoZm9yIGxvY2FsIGRldmVsb3BtZW50KVxuICBpZiAoY29udGV4dC5zaXRlPy5pZCB8fCBwcm9jZXNzLmVudi5TSVRFX0lEKSB7XG4gICAgc3RvcmVDb25maWcuc2l0ZUlEID0gY29udGV4dC5zaXRlPy5pZCB8fCBwcm9jZXNzLmVudi5TSVRFX0lEO1xuICB9XG5cbiAgaWYgKGNvbnRleHQudG9rZW4gfHwgcHJvY2Vzcy5lbnYuTkVUTElGWV9BVVRIX1RPS0VOKSB7XG4gICAgc3RvcmVDb25maWcudG9rZW4gPSBjb250ZXh0LnRva2VuIHx8IHByb2Nlc3MuZW52Lk5FVExJRllfQVVUSF9UT0tFTjtcbiAgfVxuXG4gIHJldHVybiBnZXRTdG9yZShzdG9yZUNvbmZpZyk7XG59XG5cbi8qKlxuICogR2V0IHNlc3Npb24tc3BlY2lmaWMgc3RhdGUga2V5XG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlS2V5KHJlcSkge1xuICAvLyBDaGVjayBmb3Igc2Vzc2lvbiBJRCBpbiBoZWFkZXJzIG9yIHF1ZXJ5IHBhcmFtc1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICBjb25zdCBzZXNzaW9uSWQgPVxuICAgIHJlcS5oZWFkZXJzLmdldD8uKFwieC1zZXNzaW9uLWlkXCIpIHx8XG4gICAgcmVxLmhlYWRlcnNbXCJ4LXNlc3Npb24taWRcIl0gfHxcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmdldChcInNlc3Npb25cIik7XG5cbiAgLy8gVXNlIHNlc3Npb24tc3BlY2lmaWMga2V5IGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIGRlZmF1bHRcbiAgcmV0dXJuIHNlc3Npb25JZCA/IGBzZXNzaW9uXyR7c2Vzc2lvbklkfWAgOiBcImRlZmF1bHRcIjtcbn1cblxuLyoqXG4gKiBMb2FkIHN0YXRlIGZyb20gQmxvYnMgb3IgcmV0dXJuIGRlZmF1bHRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZFN0YXRlKHN0b3JlLCBzdGF0ZUtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzdG9yZS5nZXQoc3RhdGVLZXkpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9XG4gICAgLy8gTm8gZXhpc3Rpbmcgc3RhdGUsIHJldHVybiBkZWZhdWx0XG4gICAgcmV0dXJuIHsgLi4uREVGQVVMVF9TVEFURSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN0YXRlIGZyb20gQmxvYnM6XCIsIGVycm9yKTtcbiAgICAvLyBSZXR1cm4gZGVmYXVsdCBzdGF0ZSBvbiBlcnJvclxuICAgIHJldHVybiB7IC4uLkRFRkFVTFRfU1RBVEUgfTtcbiAgfVxufVxuXG4vKipcbiAqIFNhdmUgc3RhdGUgdG8gQmxvYnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2F2ZVN0YXRlKHN0b3JlLCBzdGF0ZUtleSwgc3RhdGUpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzdG9yZS5zZXQoc3RhdGVLZXksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBzdGF0ZSB0byBCbG9iczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzdGF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTdGF0ZShzdG9yZSwgc3RhdGVLZXkpIHtcbiAgY29uc3QgZ2xvYmFsU3RhdGUgPSBhd2FpdCBsb2FkU3RhdGUoc3RvcmUsIHN0YXRlS2V5KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5nbG9iYWxTdGF0ZSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgLi4uZ2xvYmFsU3RhdGUubWV0YWRhdGEsXG4gICAgICByZXRyaWV2ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHNlc3Npb25JZDogc3RhdGVLZXksXG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHN0YXRlIHdpdGggdmFsaWRhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVTdGF0ZShzdG9yZSwgc3RhdGVLZXksIHVwZGF0ZXMsIGFnZW50SWQgPSBcInVzZXJcIikge1xuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIHVwZGF0ZXNcbiAgICBpZiAoIXVwZGF0ZXMgfHwgdHlwZW9mIHVwZGF0ZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXBkYXRlcyBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkIGN1cnJlbnQgc3RhdGVcbiAgICBsZXQgZ2xvYmFsU3RhdGUgPSBhd2FpdCBsb2FkU3RhdGUoc3RvcmUsIHN0YXRlS2V5KTtcblxuICAgIC8vIEFwcGx5IHVwZGF0ZXMgKGRlZXAgbWVyZ2UpXG4gICAgZ2xvYmFsU3RhdGUgPSBkZWVwTWVyZ2UoZ2xvYmFsU3RhdGUsIHVwZGF0ZXMpO1xuXG4gICAgLy8gVXBkYXRlIG1ldGFkYXRhXG4gICAgZ2xvYmFsU3RhdGUubWV0YWRhdGEubGFzdFVwZGF0ZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgZ2xvYmFsU3RhdGUubWV0YWRhdGEudmVyc2lvbiA9IChnbG9iYWxTdGF0ZS5tZXRhZGF0YS52ZXJzaW9uIHx8IDEpICsgMTtcblxuICAgIC8vIFNhdmUgdG8gQmxvYnNcbiAgICBhd2FpdCBzYXZlU3RhdGUoc3RvcmUsIHN0YXRlS2V5LCBnbG9iYWxTdGF0ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHN0YXRlOiBhd2FpdCBnZXRTdGF0ZShzdG9yZSwgc3RhdGVLZXkpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0IHN0YXRlIHRvIGluaXRpYWwgdmFsdWVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc2V0U3RhdGUoc3RvcmUsIHN0YXRlS2V5KSB7XG4gIGNvbnN0IGdsb2JhbFN0YXRlID0ge1xuICAgIC4uLkRFRkFVTFRfU1RBVEUsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB2ZXJzaW9uOiAxLFxuICAgICAgc2Vzc2lvbklkOiBzdGF0ZUtleSxcbiAgICB9LFxuICB9O1xuICBhd2FpdCBzYXZlU3RhdGUoc3RvcmUsIHN0YXRlS2V5LCBnbG9iYWxTdGF0ZSk7XG4gIHJldHVybiBnZXRTdGF0ZShzdG9yZSwgc3RhdGVLZXkpO1xufVxuXG4vKipcbiAqIExpc3QgYWxsIHNlc3Npb25zIChmb3IgYWRtaW4vZGVidWcgcHVycG9zZXMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxpc3RTZXNzaW9ucyhzdG9yZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgYmxvYnMgfSA9IGF3YWl0IHN0b3JlLmxpc3QoKTtcbiAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiAoe1xuICAgICAga2V5OiBibG9iLmtleSxcbiAgICAgIC8vIEV4dHJhY3Qgc2Vzc2lvbiBJRCBmcm9tIGtleVxuICAgICAgc2Vzc2lvbklkOiBibG9iLmtleS5zdGFydHNXaXRoKFwic2Vzc2lvbl9cIikgPyBibG9iLmtleS5yZXBsYWNlKFwic2Vzc2lvbl9cIiwgXCJcIikgOiBibG9iLmtleSxcbiAgICAgIGlzRGVmYXVsdDogYmxvYi5rZXkgPT09IFwiZGVmYXVsdFwiLFxuICAgIH0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbGlzdGluZyBzZXNzaW9uczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIERlZXAgbWVyZ2UgdXRpbGl0eSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgY29uc3Qgb3V0cHV0ID0geyAuLi50YXJnZXQgfTtcblxuICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gZGVlcE1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpdGVtKSB7XG4gIHJldHVybiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGl0ZW0pO1xufVxuXG4vKipcbiAqIE5ldGxpZnkgRnVuY3Rpb24gSGFuZGxlclxuICovXG5jb25zdCBoYW5kbGVyID0gYXN5bmMgKHJlcSwgY29udGV4dCkgPT4ge1xuICAvLyBFbmFibGUgQ09SU1xuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCI6IFwiKlwiLFxuICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVyc1wiOiBcIkNvbnRlbnQtVHlwZSwgWC1TZXNzaW9uLUlEXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCI6IFwiR0VULCBQT1NULCBQVVQsIERFTEVURSwgT1BUSU9OU1wiLFxuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICB9O1xuXG4gIC8vIEhhbmRsZSBwcmVmbGlnaHRcbiAgaWYgKHJlcS5tZXRob2QgPT09IFwiT1BUSU9OU1wiKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcIk9LXCIsIHsgaGVhZGVycyB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBCbG9icyBzdG9yZVxuICAgIGNvbnN0IHN0b3JlID0gZ2V0QmxvYlN0b3JlKGNvbnRleHQpO1xuXG4gICAgLy8gR2V0IHRoZSBzdGF0ZSBrZXkgKHNlc3Npb24tc3BlY2lmaWMgb3IgZGVmYXVsdClcbiAgICBjb25zdCBzdGF0ZUtleSA9IGdldFN0YXRlS2V5KHJlcSk7XG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aG5hbWUucmVwbGFjZShcIi8ubmV0bGlmeS9mdW5jdGlvbnMvY2FudmFzLXN0YXRlXCIsIFwiXCIpO1xuXG4gICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmdcbiAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHN0YXRlIHJlcXVlc3Q6ICR7cmVxLm1ldGhvZH0gJHtwYXRofSwgc2Vzc2lvbjogJHtzdGF0ZUtleX1gKTtcblxuICAgIC8vIEdFVCAvc3RhdGUgLSBHZXQgY3VycmVudCBzdGF0ZVxuICAgIGlmIChyZXEubWV0aG9kID09PSBcIkdFVFwiICYmIChwYXRoID09PSBcIlwiIHx8IHBhdGggPT09IFwiL1wiKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBnZXRTdGF0ZShzdG9yZSwgc3RhdGVLZXkpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShzdGF0ZSksIHtcbiAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHRVQgL3Nlc3Npb25zIC0gTGlzdCBhbGwgc2Vzc2lvbnMgKGFkbWluL2RlYnVnKVxuICAgIGlmIChyZXEubWV0aG9kID09PSBcIkdFVFwiICYmIHBhdGggPT09IFwiL3Nlc3Npb25zXCIpIHtcbiAgICAgIGNvbnN0IHNlc3Npb25zID0gYXdhaXQgbGlzdFNlc3Npb25zKHN0b3JlKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBzZXNzaW9ucyxcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbjogc3RhdGVLZXksXG4gICAgICAgIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHRVQgL2hpc3RvcnkgLSBHZXQgc3RhdGUgaGlzdG9yeSAoZGVwcmVjYXRlZCBidXQga2VwdCBmb3IgY29tcGF0aWJpbGl0eSlcbiAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBwYXRoID09PSBcIi9oaXN0b3J5XCIpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgZ2V0U3RhdGUoc3RvcmUsIHN0YXRlS2V5KTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBoaXN0b3J5OiBbXSwgLy8gTm8gbG9uZ2VyIHN0b3JpbmcgaGlzdG9yeSB3aXRoIEJsb2JzIGFwcHJvYWNoXG4gICAgICAgICAgY3VycmVudFN0YXRlOiBzdGF0ZSxcbiAgICAgICAgfSksXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFBPU1QgL3VwZGF0ZSAtIFVwZGF0ZSBzdGF0ZVxuICAgIGlmIChyZXEubWV0aG9kID09PSBcIlBPU1RcIiAmJiBwYXRoID09PSBcIi91cGRhdGVcIikge1xuICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcS5qc29uKCk7XG4gICAgICBjb25zdCB7IHVwZGF0ZXMsIGFnZW50SWQgfSA9IGJvZHk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZVN0YXRlKHN0b3JlLCBzdGF0ZUtleSwgdXBkYXRlcywgYWdlbnRJZCk7XG5cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5zdWNjZXNzID8gMjAwIDogNDAwLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUE9TVCAvcmVzZXQgLSBSZXNldCBzdGF0ZVxuICAgIGlmIChyZXEubWV0aG9kID09PSBcIlBPU1RcIiAmJiBwYXRoID09PSBcIi9yZXNldFwiKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHJlc2V0U3RhdGUoc3RvcmUsIHN0YXRlS2V5KTtcblxuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBERUxFVEUgL3Nlc3Npb24gLSBEZWxldGUgYSBzcGVjaWZpYyBzZXNzaW9uXG4gICAgaWYgKHJlcS5tZXRob2QgPT09IFwiREVMRVRFXCIgJiYgcGF0aCA9PT0gXCIvc2Vzc2lvblwiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzdG9yZS5kZWxldGUoc3RhdGVLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBgU2Vzc2lvbiAke3N0YXRlS2V5fSBkZWxldGVkYCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kIG5vdCBhbGxvd2VkXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXJyb3I6IGBNZXRob2QgJHtyZXEubWV0aG9kfSBub3QgYWxsb3dlZCBmb3IgcGF0aCAke3BhdGh9YCxcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IDQwNSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH1cbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgc3RhdGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBlcnJvcjogXCJGYWlsZWQgdG8gcHJvY2VzcyBjYW52YXMgc3RhdGUgcmVxdWVzdFwiLFxuICAgICAgICBkZXRhaWxzOiBlcnJvci5tZXNzYWdlLFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7OztBQU1BLFNBQVMsZ0JBQWdCO0FBR3pCLElBQU0sZ0JBQWdCO0FBQUEsRUFDcEIsWUFBWTtBQUFBLElBQ1Ysc0JBQXNCO0FBQUE7QUFBQSxJQUN0QixnQkFBZ0I7QUFBQTtBQUFBLElBQ2hCLGdCQUFnQjtBQUFBO0FBQUEsSUFDaEIsY0FBYztBQUFBO0FBQUEsSUFDZCxjQUFjO0FB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
